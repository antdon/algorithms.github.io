<!doctype html><html><head><meta charset=utf-8><meta name=generator content="Hugo 0.68.3"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><meta name=keywords content><meta name=description content><meta name=author content="Anton Donohue"><meta name=copyright content="Anton Donohue"><meta http-equiv=content-language content="zh,en"><link rel=canonical href=https://antdon.me/posts/fibbonacci-number/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>Fibbonacci Numbers&nbsp;&ndash;&nbsp;Anton's Algorithms</title><link rel=preconnect href=https://cdn.jsdelivr.net/ crossorigin><link rel=dns-prefetch href=https://cdn.jsdelivr.net/><link rel=dns-prefetch href=https://fonts.gstatic.com/><link rel=preload href=/css/core.min.4f47bbabbe1a95ba05bcbf7bff887938361467f1f25096a6a09541fcdfaf6f9eb55c16db012e40db452cfb1b4c0fc26a.css as=style onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel=stylesheet href=/css/core.min.4f47bbabbe1a95ba05bcbf7bff887938361467f1f25096a6a09541fcdfaf6f9eb55c16db012e40db452cfb1b4c0fc26a.css integrity=sha384-T0e7q74alboFvL97/4h5ODYUZ/HyUJamoJVB/N+vb561XBbbAS5A20Us+xtMD8Jq></noscript><style type=text/css>*,::before,::after{margin:0;padding:0;box-sizing:border-box}html{font-family:-system-ui,-apple-system,BlinkMacSystemFont,helvetica neue,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol;font-size:17px;font-weight:400;line-height:1.7;scroll-behavior:smooth;transition:color .3s,background-color .3s;word-wrap:break-word;-webkit-text-size-adjust:100%}html[data-theme=dark] img{opacity:.65;transition:opacity .5s ease-in-out}html{background:#fff;--site-name-color: #3f4b67;--color-primary: #005ab4;--link-underline: #90cff9;--blockquote-border-left: 6px solid #0051a2;--block-background-color: #f7faff;--pag-background-color: rgba(0, 122, 255, .5);--box-shadow: 1px 1px 2px rgba(0,0,0,.125);--title-color: #303033;--body-color: #444}html[data-theme=dark]{background:#22272e;--site-name-color: #539bf5;--color-primary: #99bde1;--link-underline: #0051a2;--blockquote-border-left: 6px solid #5176bf;--block-background-color: #002c58;--box-shadow: none;--title-color: #dadada;--body-color: #e9e9e9}h1,h2,h3,h4,h5,h6{font-weight:600;line-height:1.3;margin-block-start:0;margin-block-end:0}h1{font-size:26px}h2{font-size:24px}h3{font-size:22px}section>h1{color:var(--title-color)}a{color:var(--color-primary);text-decoration-thickness:.15rem;text-decoration-color:var(--link-underline)}a:hover{text-decoration-color:var(--color-primary)}.wrapper{display:grid;grid-template-columns:1fr min(65ch,calc(100% - 64px)) 1fr;grid-column-gap:32px}.wrapper>section{grid-column:2}.header{margin:20px 0;display:-webkit-flex;display:flex;flex-wrap:wrap;text-align:initial;padding:15px 0;border-bottom:1px solid #f0f0f0;justify-content:space-between;align-items:baseline}.site-name{display:inline-block;font-weight:600;font-size:21px;color:var(--site-name-color)}.site-logo{height:38px;border-radius:3px;vertical-align:middle;margin-right:8px}.nav-item{display:inline-block;font-size:18px;padding:4px 6px;margin:2px 3px 2px 0;line-height:1.5;white-space:nowrap}.data-theme-btn{border:none;vertical-align:middle;transition:.3s;background-color:Transparent;background-repeat:no-repeat;cursor:pointer;overflow:hidden;outline:none;padding-right:0;padding-left:0}html[data-theme=light] .light-hidden{display:none}html[data-theme=dark] .dark-hidden{display:none}.note-list{margin:0;padding:0;list-style:none}.note-list .item{position:relative;width:100%;margin-top:25px}.note-list .item:last-child{border:0!important}.note-title{font-size:19px;font-weight:700}.note-date,.note-content{font-size:15px;text-decoration:none;color:var(--body-color)}.note-content,.note-imgs,.note-labels{margin-top:4px;text-align:justify;text-justify:inter-word}.article-tag,.article-category{display:inline-block;font-size:15px;line-height:1;padding:4px 6px;margin:2px 3px 2px 0;white-space:nowrap;border-radius:3px}.article-category{color:#3a8c42}.article-category .hashtag,.article-tag .hashtag{font-weight:700;opacity:.5}.footer{font-size:13px;margin:40px 0 20px}.footer-wrap{text-align:center;color:var(--body-color)}.tag-cloud{margin:2em 0 3em;text-align:center}.tag-cloud-tags{display:inline-block;position:relative;margin:5px;word-wrap:break-word;overflow-wrap:break-word}.archive-year{font-size:20px;font-weight:800;color:var(--title-color);margin-top:20px;margin-bottom:10px}.archive-list{list-style:none}.archive-date{flex:0 0 100px;color:var(--title-color)}.archive-text{color:var(--body-color)}ul.archive-list li{display:flex}.article-containter{margin-bottom:20px}.article-header{margin:20px 0}.article-date{font-size:14px;margin-top:20px;color:#838387}.lastmod-date{font-size:14px;color:#838387}.markdown-body{color:var(--body-color)}.markdown-body p{margin-top:0;margin-bottom:20px}.pagination{display:block;text-align:center;margin:20px 0 40px}.pagination ul{display:inline-block;list-style:none;font-weight:600;padding:0;margin:0}.pagination ul li{display:inline}.pagination ul li a{color:var(--color-primary);float:left;padding:8px 16px;text-decoration:none}.pagination ul li a:hover:not(.active){background-color:var(--pag-background-color)}.pagination ul li a.active{background-color:var(--color-primary);color:var(--block-background-color)}</style></head><body><div class=wrapper><section id=header class=header><div class=header-left><a href=/><p class=site-name>Anton's Algorithms</p></a></div><div class=header-right></div></section><section id=content><div class=article-containter><section class=article-header><h1>Fibbonacci Numbers</h1><p class=article-date>2022-07-06</p></section><section class=article-labels><a class="article-tag li" href=/tags/algorithms/><span class=hashtag>#</span>algorithms</a><a class="article-tag li" href=/tags/code/><span class=hashtag>#</span>code</a></section><article class=markdown-body><p><a href=https://leetcode.com/problems/fibonacci-number/ target=_blank rel=noopener>link to problem</a></p><h2 id=problem-explanation>Problem explanation</h2><p>The problem is asking us to return the respective fibbonacci number of the input. Where the output should be given by the function f(0) = 0, f(1) = 1, f(n) = f(n-1) + f(n-2).</p><h2 id=solution>Solution</h2><p>This is a common example of a problem that is best solved using recursion. We start by defining our base cases.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#ff79c6>if</span> n <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>:
	<span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>
<span style=color:#ff79c6>elif</span> n <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>1</span>:
	<span style=color:#ff79c6>return</span> <span style=color:#bd93f9>1</span>
</code></pre></div><p>These are our stop conditions. The bottom of the tower of recursive calls that we are building.
Next we want to do our recursive case that is essentially spelt out in the problem statement.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#ff79c6>else</span>:
	<span style=color:#ff79c6>return</span> self<span style=color:#ff79c6>.</span>fib(n<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>) <span style=color:#ff79c6>+</span> self<span style=color:#ff79c6>.</span>fib(n<span style=color:#ff79c6>-</span><span style=color:#bd93f9>2</span>)
</code></pre></div><p>Here we are calling fib inside of fib. But each time we are reducing n and hence we will eventually hit our base case. This works by building up slowly take n = 7 for example</p><p>fib(7) = fib(6) + fib(5)
fib(7) = (fib(5) + fib(3)) + (fib(4) + fib(2))
fib(7) = ((fib(4) + fib(3)) + fib(2) + fib(1)) + ((fib(3) + fib(2)) + (fib(1) + fib(0)))
&mldr;</p><p>I&rsquo;m sure I&rsquo;ve already messed up my bracktes but I&rsquo;m sure you can see the pattern. Each fib call breaks into two more fib calls with smaller n values until it eventually reaches either fib(1) or fib(0). When we reach these base cases we can sub in 1 and 0 respectively and finally do our addition.
Gaining a intuition for writing such algorithms is tricky and will take time but as long as you first define the base case and then make sure that the recursive case is reducing each time you can trust that your algorithm will eventually resolve.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Solution</span>:
    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>fib</span>(self, n: <span style=color:#8be9fd;font-style:italic>int</span>) <span style=color:#ff79c6>-&gt;</span> <span style=color:#8be9fd;font-style:italic>int</span>:
        <span style=color:#ff79c6>if</span> n <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>:
            <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>
        <span style=color:#ff79c6>elif</span> n <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>1</span>:
            <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>1</span>
        <span style=color:#ff79c6>else</span>:
            <span style=color:#ff79c6>return</span> self<span style=color:#ff79c6>.</span>fib(n<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>) <span style=color:#ff79c6>+</span> self<span style=color:#ff79c6>.</span>fib(n<span style=color:#ff79c6>-</span><span style=color:#bd93f9>2</span>)
</code></pre></div><h2 id=optimisation>Optimisation</h2><p>If we look at the example of fib(7) above we can see that many numbers are repeated. In the last line I attempted fib(3) occurs twice. Each time we are breaking fib(3) up into fin(2) and fib(1) although we have already done this computation. Essentially if we could store the values that we have already calculated we could only have to calculate them once and then we can reuse them.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Solution</span>:
    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>fib</span>(self, n: <span style=color:#8be9fd;font-style:italic>int</span>) <span style=color:#ff79c6>-&gt;</span> <span style=color:#8be9fd;font-style:italic>int</span>:
        hash_map <span style=color:#ff79c6>=</span>{}
        <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>f</span>(n):
            <span style=color:#ff79c6>if</span>(hash_map<span style=color:#ff79c6>.</span>get(n,<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>)<span style=color:#ff79c6>!=-</span><span style=color:#bd93f9>1</span>):
                <span style=color:#ff79c6>return</span> hash_map[n]
            
            <span style=color:#ff79c6>if</span>(n<span style=color:#ff79c6>==</span><span style=color:#bd93f9>0</span> <span style=color:#ff79c6>or</span> n<span style=color:#ff79c6>==</span><span style=color:#bd93f9>1</span>):
                hash_map[n] <span style=color:#ff79c6>=</span> n
                <span style=color:#ff79c6>return</span> hash_map[n]
            
            hash_map[n] <span style=color:#ff79c6>=</span> f(n<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>)<span style=color:#ff79c6>+</span>f(n<span style=color:#ff79c6>-</span><span style=color:#bd93f9>2</span>)
            
            <span style=color:#ff79c6>return</span> hash_map[n]
        <span style=color:#ff79c6>return</span> f(n)
</code></pre></div><p>The below code stores them in a hashtable. It first declares the hashtable and then its recursive helper function. Each iteration it first checks if the value is stored in the table.</p><p><em>This is done with some fun syntax where the second argument of get is a default value that is returned if the value is not found in the table. Hence get(n, -1) checks if n is in the hashmap and if not it returns -1, a value that could not be returned by any n).</em></p><p>Then it checks for base cases. And finally the recursive call, however this time assigning the recursive calls value to the value of n in their hashmap so that they look it up if the need it again later. It&rsquo;s important to understand that hashmaps have O(1) lookup in the average case, you can read more about that <a href=https://computersciencehub.io/python/python-dictionary-time-complexity/ target=_blank rel=noopener>here</a>.</p><p>This type of saving the values of recursive calls is a common operation and is needed to speed up a lot of functional programming. So the good folks who make python created a handy decorator that you can add to your regular shmegular functions.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#ff79c6>import</span> functools

<span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Solution</span>:
    @functools.cache
    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>fib</span>(self, n: <span style=color:#8be9fd;font-style:italic>int</span>) <span style=color:#ff79c6>-&gt;</span> <span style=color:#8be9fd;font-style:italic>int</span>:
        <span style=color:#ff79c6>if</span> n <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>:
            <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>0</span>
        <span style=color:#ff79c6>elif</span> n <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>1</span>:
            <span style=color:#ff79c6>return</span> <span style=color:#bd93f9>1</span>
        <span style=color:#ff79c6>else</span>:
            <span style=color:#ff79c6>return</span> self<span style=color:#ff79c6>.</span>fib(n<span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>) <span style=color:#ff79c6>+</span> self<span style=color:#ff79c6>.</span>fib(n<span style=color:#ff79c6>-</span><span style=color:#bd93f9>2</span>)
</code></pre></div><p>This function will perform aprox as well as the solution with hashing and required far less typing.</p></article></div><section class=article-navigation><p><a class=link href=/posts/longest-consecutive-sequence/><span class=li></span>Longest Consecutive Sequence</a class="link"></p></section></section><section id=footer class="footer max-body-width"><div class=footer-wrap><p class=copyright>Anton's Algorithms</p></div><div class=footer-wrap><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener>CC BY-NC-SA 4.0</a><span> | </span><a href=/index.xml target=_blank rel=noopener>RSS</a></div><div class=footer-wrap><p class=powerby><span>Powered by </span><a href=https://gohugo.io target=_blank rel=noopener>Hugo</a><span> and the </span><a href=https://github.com/qdzhang/hugo-notepadium-mod target=_blank rel=noopener>Notepadium-mod</a></p></div><div class=footer-wrap><a onclick='window.scrollTo({top:0,behavior:"smooth"});'>^ TOP ^</a></div></section></div></body></html>