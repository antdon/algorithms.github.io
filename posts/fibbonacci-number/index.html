<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Fibbonacci Numbers | Anton&#39;s Daily Algorithm</title>
<meta name="keywords" content="algorithms, code">
<meta name="description" content="link to problem
Problem explanation The problem is asking us to return the respective fibbonacci number of the input. Where the output should be given by the function f(0) = 0, f(1) = 1, f(n) = f(n-1) &#43; f(n-2).
Solution This is a common example of a problem that is best solved using recursion. We start by defining our base cases.
if n == 0: return 0 elif n == 1: return 1 These are our stop conditions.">
<meta name="author" content="">
<link rel="canonical" href="https://antdon.me/posts/fibbonacci-number/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.41f2d211c00e636a3c229c52ef2d4299a66891ae66771098993b13bca7972ae6.css" integrity="sha256-QfLSEcAOY2o8IpxS7y1CmaZoka5mdxCYmTsTvKeXKuY=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://antdon.me/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://antdon.me/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://antdon.me/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://antdon.me/apple-touch-icon.png">
<link rel="mask-icon" href="https://antdon.me/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Fibbonacci Numbers" />
<meta property="og:description" content="link to problem
Problem explanation The problem is asking us to return the respective fibbonacci number of the input. Where the output should be given by the function f(0) = 0, f(1) = 1, f(n) = f(n-1) &#43; f(n-2).
Solution This is a common example of a problem that is best solved using recursion. We start by defining our base cases.
if n == 0: return 0 elif n == 1: return 1 These are our stop conditions." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://antdon.me/posts/fibbonacci-number/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-06T16:52:11&#43;10:00" />
<meta property="article:modified_time" content="2022-07-06T16:52:11&#43;10:00" /><meta property="og:site_name" content="Anton&#39;s Daily Algorithm" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Fibbonacci Numbers"/>
<meta name="twitter:description" content="link to problem
Problem explanation The problem is asking us to return the respective fibbonacci number of the input. Where the output should be given by the function f(0) = 0, f(1) = 1, f(n) = f(n-1) &#43; f(n-2).
Solution This is a common example of a problem that is best solved using recursion. We start by defining our base cases.
if n == 0: return 0 elif n == 1: return 1 These are our stop conditions."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Fibbonacci Numbers",
      "item": "https://antdon.me/posts/fibbonacci-number/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Fibbonacci Numbers",
  "name": "Fibbonacci Numbers",
  "description": "link to problem\nProblem explanation The problem is asking us to return the respective fibbonacci number of the input. Where the output should be given by the function f(0) = 0, f(1) = 1, f(n) = f(n-1) + f(n-2).\nSolution This is a common example of a problem that is best solved using recursion. We start by defining our base cases.\nif n == 0: return 0 elif n == 1: return 1 These are our stop conditions.",
  "keywords": [
    "algorithms", "code"
  ],
  "articleBody": "link to problem\nProblem explanation The problem is asking us to return the respective fibbonacci number of the input. Where the output should be given by the function f(0) = 0, f(1) = 1, f(n) = f(n-1) + f(n-2).\nSolution This is a common example of a problem that is best solved using recursion. We start by defining our base cases.\nif n == 0: return 0 elif n == 1: return 1 These are our stop conditions. The bottom of the tower of recursive calls that we are building. Next we want to do our recursive case that is essentially spelt out in the problem statement.\nelse: return self.fib(n-1) + self.fib(n-2) Here we are calling fib inside of fib. But each time we are reducing n and hence we will eventually hit our base case. This works by building up slowly take n = 7 for example\nfib(7) = fib(6) + fib(5) fib(7) = (fib(5) + fib(3)) + (fib(4) + fib(2)) fib(7) = ((fib(4) + fib(3)) + fib(2) + fib(1)) + ((fib(3) + fib(2)) + (fib(1) + fib(0))) …\nI’m sure I’ve already messed up my bracktes but I’m sure you can see the pattern. Each fib call breaks into two more fib calls with smaller n values until it eventually reaches either fib(1) or fib(0). When we reach these base cases we can sub in 1 and 0 respectively and finally do our addition. Gaining a intuition for writing such algorithms is tricky and will take time but as long as you first define the base case and then make sure that the recursive case is reducing each time you can trust that your algorithm will eventually resolve.\nclass Solution: def fib(self, n: int) - int: if n == 0: return 0 elif n == 1: return 1 else: return self.fib(n-1) + self.fib(n-2) Optimisation If we look at the example of fib(7) above we can see that many numbers are repeated. In the last line I attempted fib(3) occurs twice. Each time we are breaking fib(3) up into fin(2) and fib(1) although we have already done this computation. Essentially if we could store the values that we have already calculated we could only have to calculate them once and then we can reuse them.\nclass Solution: def fib(self, n: int) - int: hash_map ={} def f(n): if(hash_map.get(n,-1)!=-1): return hash_map[n] if(n==0 or n==1): hash_map[n] = n return hash_map[n] hash_map[n] = f(n-1)+f(n-2) return hash_map[n] return f(n) The below code stores them in a hashtable. It first declares the hashtable and then its recursive helper function. Each iteration it first checks if the value is stored in the table.\nThis is done with some fun syntax where the second argument of get is a default value that is returned if the value is not found in the table. Hence get(n, -1) checks if n is in the hashmap and if not it returns -1, a value that could not be returned by any n).\nThen it checks for base cases. And finally the recursive call, however this time assigning the recursive calls value to the value of n in their hashmap so that they look it up if the need it again later. It’s important to understand that hashmaps have O(1) lookup in the average case, you can read more about that here.\nThis type of saving the values of recursive calls is a common operation and is needed to speed up a lot of functional programming. So the good folks who make python created a handy decorator that you can add to your regular shmegular functions.\nimport functools class Solution: @functools.cache def fib(self, n: int) - int: if n == 0: return 0 elif n == 1: return 1 else: return self.fib(n-1) + self.fib(n-2) This function will perform aprox as well as the solution with hashing and required far less typing.\n",
  "wordCount" : "641",
  "inLanguage": "en",
  "datePublished": "2022-07-06T16:52:11+10:00",
  "dateModified": "2022-07-06T16:52:11+10:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://antdon.me/posts/fibbonacci-number/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Anton's Daily Algorithm",
    "logo": {
      "@type": "ImageObject",
      "url": "https://antdon.me/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://antdon.me" accesskey="h" title="Anton&#39;s Daily Algorithm (Alt + H)">Anton&#39;s Daily Algorithm</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Fibbonacci Numbers
    </h1>
    <div class="post-meta"><span title='2022-07-06 16:52:11 +1000 AEST'>July 6, 2022</span>

</div>
  </header> 
  <div class="post-content"><p><a href="https://leetcode.com/problems/fibonacci-number/">link to problem</a></p>
<h2 id="problem-explanation">Problem explanation<a hidden class="anchor" aria-hidden="true" href="#problem-explanation">#</a></h2>
<p>The problem is asking us to return the respective fibbonacci number of the input. Where the output should be given by the function f(0) = 0, f(1) = 1, f(n) = f(n-1) + f(n-2).</p>
<h2 id="solution">Solution<a hidden class="anchor" aria-hidden="true" href="#solution">#</a></h2>
<p>This is a common example of a problem that is best solved using recursion. We start by defining our base cases.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">if</span> n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
<span style="color:#66d9ef">elif</span> n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
</code></pre></div><p>These are our stop conditions. The bottom of the tower of recursive calls that we are building.
Next we want to do our recursive case that is essentially spelt out in the problem statement.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">else</span>:
	<span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>fib(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>fib(n<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>)
</code></pre></div><p>Here we are calling fib inside of fib. But each time we are reducing n and hence we will eventually hit our base case. This works by building up slowly take n = 7 for example</p>
<p>fib(7) = fib(6) + fib(5)
fib(7) = (fib(5) + fib(3)) + (fib(4) + fib(2))
fib(7) = ((fib(4) + fib(3)) + fib(2) + fib(1)) + ((fib(3) + fib(2)) + (fib(1) + fib(0)))
&hellip;</p>
<p>I&rsquo;m sure I&rsquo;ve already messed up my bracktes but I&rsquo;m sure you can see the pattern. Each fib call breaks into two more fib calls with smaller n values until it eventually reaches either fib(1) or fib(0). When we reach these base cases we can sub in 1 and 0 respectively and finally do our addition.
Gaining a intuition for writing such algorithms is tricky and will take time but as long as you first define the base case and then make sure that the recursive case is reducing each time you can trust that your algorithm will eventually resolve.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fib</span>(self, n: int) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#66d9ef">if</span> n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">elif</span> n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>fib(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>fib(n<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>)
</code></pre></div><h2 id="optimisation">Optimisation<a hidden class="anchor" aria-hidden="true" href="#optimisation">#</a></h2>
<p>If we look at the example of fib(7) above we can see that many numbers are repeated. In the last line I attempted fib(3) occurs twice. Each time we are breaking fib(3) up into fin(2) and fib(1) although we have already done this computation. Essentially if we could store the values that we have already calculated we could only have to calculate them once and then we can reuse them.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fib</span>(self, n: int) <span style="color:#f92672">-&gt;</span> int:
        hash_map <span style="color:#f92672">=</span>{}
        <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">f</span>(n):
            <span style="color:#66d9ef">if</span>(hash_map<span style="color:#f92672">.</span>get(n,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">!=-</span><span style="color:#ae81ff">1</span>):
                <span style="color:#66d9ef">return</span> hash_map[n]
            
            <span style="color:#66d9ef">if</span>(n<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> n<span style="color:#f92672">==</span><span style="color:#ae81ff">1</span>):
                hash_map[n] <span style="color:#f92672">=</span> n
                <span style="color:#66d9ef">return</span> hash_map[n]
            
            hash_map[n] <span style="color:#f92672">=</span> f(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">+</span>f(n<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>)
            
            <span style="color:#66d9ef">return</span> hash_map[n]
        <span style="color:#66d9ef">return</span> f(n)
</code></pre></div><p>The below code stores them in a hashtable. It first declares the hashtable and then its recursive helper function. Each iteration it first checks if the value is stored in the table.</p>
<p><em>This is done with some fun syntax where the second argument of get is a default value that is returned if the value is not found in the table. Hence get(n, -1) checks if n is in the hashmap and if not it returns -1, a value that could not be returned by any n).</em></p>
<p>Then it checks for base cases. And finally the recursive call, however this time assigning the recursive calls value to the value of n in their hashmap so that they look it up if the need it again later. It&rsquo;s important to understand that hashmaps have O(1) lookup in the average case, you can read more about that <a href="https://computersciencehub.io/python/python-dictionary-time-complexity/">here</a>.</p>
<p>This type of saving the values of recursive calls is a common operation and is needed to speed up a lot of functional programming. So the good folks who make python created a handy decorator that you can add to your regular shmegular functions.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> functools

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#a6e22e">@functools.cache</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fib</span>(self, n: int) <span style="color:#f92672">-&gt;</span> int:
        <span style="color:#66d9ef">if</span> n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
        <span style="color:#66d9ef">elif</span> n <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>fib(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#f92672">+</span> self<span style="color:#f92672">.</span>fib(n<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>)
</code></pre></div><p>This function will perform aprox as well as the solution with hashing and required far less typing.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://antdon.me/tags/algorithms/">algorithms</a></li>
      <li><a href="https://antdon.me/tags/code/">code</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://antdon.me">Anton&#39;s Daily Algorithm</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
