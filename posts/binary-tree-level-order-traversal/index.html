<!doctype html><html><head><meta charset=utf-8><meta name=generator content="Hugo 0.68.3"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><meta name=keywords content><meta name=description content><meta name=author content="Anton Donohue"><meta name=copyright content="Anton Donohue"><meta http-equiv=content-language content="zh,en"><link rel=canonical href=https://antdon.me/posts/binary-tree-level-order-traversal/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>Binary Tree Level Order Traversal&nbsp;&ndash;&nbsp;Anton's Algorithms</title><link rel=preconnect href=https://cdn.jsdelivr.net/ crossorigin><link rel=dns-prefetch href=https://cdn.jsdelivr.net/><link rel=dns-prefetch href=https://fonts.gstatic.com/><link rel=preload href=/css/core.min.4f47bbabbe1a95ba05bcbf7bff887938361467f1f25096a6a09541fcdfaf6f9eb55c16db012e40db452cfb1b4c0fc26a.css as=style onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel=stylesheet href=/css/core.min.4f47bbabbe1a95ba05bcbf7bff887938361467f1f25096a6a09541fcdfaf6f9eb55c16db012e40db452cfb1b4c0fc26a.css integrity=sha384-T0e7q74alboFvL97/4h5ODYUZ/HyUJamoJVB/N+vb561XBbbAS5A20Us+xtMD8Jq></noscript><style type=text/css>*,::before,::after{margin:0;padding:0;box-sizing:border-box}html{font-family:-system-ui,-apple-system,BlinkMacSystemFont,helvetica neue,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol;font-size:17px;font-weight:400;line-height:1.7;scroll-behavior:smooth;transition:color .3s,background-color .3s;word-wrap:break-word;-webkit-text-size-adjust:100%}html[data-theme=dark] img{opacity:.65;transition:opacity .5s ease-in-out}html{background:#fff;--site-name-color: #3f4b67;--color-primary: #005ab4;--link-underline: #90cff9;--blockquote-border-left: 6px solid #0051a2;--block-background-color: #f7faff;--pag-background-color: rgba(0, 122, 255, .5);--box-shadow: 1px 1px 2px rgba(0,0,0,.125);--title-color: #303033;--body-color: #444}html[data-theme=dark]{background:#22272e;--site-name-color: #539bf5;--color-primary: #99bde1;--link-underline: #0051a2;--blockquote-border-left: 6px solid #5176bf;--block-background-color: #002c58;--box-shadow: none;--title-color: #dadada;--body-color: #e9e9e9}h1,h2,h3,h4,h5,h6{font-weight:600;line-height:1.3;margin-block-start:0;margin-block-end:0}h1{font-size:26px}h2{font-size:24px}h3{font-size:22px}section>h1{color:var(--title-color)}a{color:var(--color-primary);text-decoration-thickness:.15rem;text-decoration-color:var(--link-underline)}a:hover{text-decoration-color:var(--color-primary)}.wrapper{display:grid;grid-template-columns:1fr min(65ch,calc(100% - 64px)) 1fr;grid-column-gap:32px}.wrapper>section{grid-column:2}.header{margin:20px 0;display:-webkit-flex;display:flex;flex-wrap:wrap;text-align:initial;padding:15px 0;border-bottom:1px solid #f0f0f0;justify-content:space-between;align-items:baseline}.site-name{display:inline-block;font-weight:600;font-size:21px;color:var(--site-name-color)}.site-logo{height:38px;border-radius:3px;vertical-align:middle;margin-right:8px}.nav-item{display:inline-block;font-size:18px;padding:4px 6px;margin:2px 3px 2px 0;line-height:1.5;white-space:nowrap}.data-theme-btn{border:none;vertical-align:middle;transition:.3s;background-color:Transparent;background-repeat:no-repeat;cursor:pointer;overflow:hidden;outline:none;padding-right:0;padding-left:0}html[data-theme=light] .light-hidden{display:none}html[data-theme=dark] .dark-hidden{display:none}.note-list{margin:0;padding:0;list-style:none}.note-list .item{position:relative;width:100%;margin-top:25px}.note-list .item:last-child{border:0!important}.note-title{font-size:19px;font-weight:700}.note-date,.note-content{font-size:15px;text-decoration:none;color:var(--body-color)}.note-content,.note-imgs,.note-labels{margin-top:4px;text-align:justify;text-justify:inter-word}.article-tag,.article-category{display:inline-block;font-size:15px;line-height:1;padding:4px 6px;margin:2px 3px 2px 0;white-space:nowrap;border-radius:3px}.article-category{color:#3a8c42}.article-category .hashtag,.article-tag .hashtag{font-weight:700;opacity:.5}.footer{font-size:13px;margin:40px 0 20px}.footer-wrap{text-align:center;color:var(--body-color)}.tag-cloud{margin:2em 0 3em;text-align:center}.tag-cloud-tags{display:inline-block;position:relative;margin:5px;word-wrap:break-word;overflow-wrap:break-word}.archive-year{font-size:20px;font-weight:800;color:var(--title-color);margin-top:20px;margin-bottom:10px}.archive-list{list-style:none}.archive-date{flex:0 0 100px;color:var(--title-color)}.archive-text{color:var(--body-color)}ul.archive-list li{display:flex}.article-containter{margin-bottom:20px}.article-header{margin:20px 0}.article-date{font-size:14px;margin-top:20px;color:#838387}.lastmod-date{font-size:14px;color:#838387}.markdown-body{color:var(--body-color)}.markdown-body p{margin-top:0;margin-bottom:20px}.pagination{display:block;text-align:center;margin:20px 0 40px}.pagination ul{display:inline-block;list-style:none;font-weight:600;padding:0;margin:0}.pagination ul li{display:inline}.pagination ul li a{color:var(--color-primary);float:left;padding:8px 16px;text-decoration:none}.pagination ul li a:hover:not(.active){background-color:var(--pag-background-color)}.pagination ul li a.active{background-color:var(--color-primary);color:var(--block-background-color)}</style></head><body><div class=wrapper><section id=header class=header><div class=header-left><a href=/><p class=site-name>Anton's Algorithms</p></a></div><div class=header-right></div></section><section id=content><div class=article-containter><section class=article-header><h1>Binary Tree Level Order Traversal</h1><p class=article-date>2022-07-13</p></section><section class=article-labels><a class="article-tag li" href=/tags/algorithms/><span class=hashtag>#</span>algorithms</a><a class="article-tag li" href=/tags/code/><span class=hashtag>#</span>code</a></section><article class=markdown-body><h1 id=problem-explanation>Problem Explanation</h1><p>The question is asking us to take a tree and put it in a list of lists, where each sublist represents a level of the tree. A level of a node is defined by the minimum number of function calls it would take to get from the root of the tree to the node in question.</p><h1 id=solution>Solution</h1><p>Being able to have a tree in this form is very useful. I in fact used this exact technique in the [[Binary Tree Right Side View]] question. If you don&rsquo;t understand it after reading this, perhaps reading that explanation could prove helpful.</p><p>First, we want to link each node to its respective level. To do this, we are going to create a helper function. This function we will use to recurse through the tree and place each node, and its respective level into a hash map. If you&rsquo;re not comfortable with recursion, yet I recommend reading my [[Fibbonacci Number]] explanation before continuing. The way we iterate through a tree is that each function call will take a child node of the current node. Furthermore, we can have a level variable that allows us to keep track of what level we are up to. Also note that python dictionaries are pass by reference, so the dictionary will stay edited after we&rsquo;ve changed it without us having to override it using a return statement.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>levels</span>(self, root, levels, level):
        <span style=color:#ff79c6>if</span> root <span style=color:#ff79c6>is</span> <span style=color:#ff79c6>not</span> None:
            levels[root] <span style=color:#ff79c6>=</span> level
            self<span style=color:#ff79c6>.</span>levels(root<span style=color:#ff79c6>.</span>left, levels, level <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>)
            self<span style=color:#ff79c6>.</span>levels(root<span style=color:#ff79c6>.</span>right, levels, level <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>)
        <span style=color:#ff79c6>else</span>:
            <span style=color:#ff79c6>return</span>
</code></pre></div><p>This uses the nodes themselves as keys and links them to their respective level.</p><p>Next, we have to call this function from our main function. We want levels to start as an empty dictionary and the first level to be 0.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>levelOrder</span>(self, root: Optional[TreeNode]) <span style=color:#ff79c6>-&gt;</span> List[List[<span style=color:#8be9fd;font-style:italic>int</span>]]:
        levels <span style=color:#ff79c6>=</span> {}
        self<span style=color:#ff79c6>.</span>levels(root, levels, <span style=color:#bd93f9>0</span>)
</code></pre></div><p>Next, we want to have a list that contains an empty list for each level. Once we have that, we will be able to just append each node&rsquo;s value into the sublist that represents its level. Note that we use <code>range(max(levels.values()) + 1)</code> because since the range function is typically used with <code>range(len(someArray))</code> the people who designed python made range be exclusive on the top end so <code>for i in range(3): print(i)</code> will print 0, 1, 2.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>        out <span style=color:#ff79c6>=</span> []
        <span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>in</span> <span style=color:#8be9fd;font-style:italic>range</span>(<span style=color:#8be9fd;font-style:italic>max</span>(levels<span style=color:#ff79c6>.</span>values()) <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>):
            out<span style=color:#ff79c6>.</span>append([])
</code></pre></div><p>Great! Now we can just go through each node, level pair and append the node&rsquo;s value into the out list of lists and return.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>        <span style=color:#ff79c6>for</span> (node, level) <span style=color:#ff79c6>in</span> levels<span style=color:#ff79c6>.</span>items():
            out[level]<span style=color:#ff79c6>.</span>append(node<span style=color:#ff79c6>.</span>val)
        <span style=color:#ff79c6>return</span> out
</code></pre></div><p>Now we&rsquo;re all done. The only issue is the edge case where they can give us the empty tree. In this case, levels will remain an empty dictionary and max(level.values()) will throw an error because python doesn&rsquo;t know what to return as the max of an empty list. We can fix this with a check at the start of our code</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>        <span style=color:#ff79c6>if</span> levels <span style=color:#ff79c6>==</span> {}:
            <span style=color:#ff79c6>return</span> []
</code></pre></div><p>And finally plugging it all together, we get the final solution.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Solution</span>:
    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>levelOrder</span>(self, root: Optional[TreeNode]) <span style=color:#ff79c6>-&gt;</span> List[List[<span style=color:#8be9fd;font-style:italic>int</span>]]:
        levels <span style=color:#ff79c6>=</span> {}
        self<span style=color:#ff79c6>.</span>levels(root, levels, <span style=color:#bd93f9>0</span>)
        <span style=color:#ff79c6>if</span> levels <span style=color:#ff79c6>==</span> {}:
            <span style=color:#ff79c6>return</span> []
        out <span style=color:#ff79c6>=</span> []
        <span style=color:#ff79c6>for</span> i <span style=color:#ff79c6>in</span> <span style=color:#8be9fd;font-style:italic>range</span>(<span style=color:#8be9fd;font-style:italic>max</span>(levels<span style=color:#ff79c6>.</span>values()) <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>):
            out<span style=color:#ff79c6>.</span>append([])
        <span style=color:#ff79c6>for</span> (node, level) <span style=color:#ff79c6>in</span> levels<span style=color:#ff79c6>.</span>items():
            out[level]<span style=color:#ff79c6>.</span>append(node<span style=color:#ff79c6>.</span>val)
        <span style=color:#ff79c6>return</span> out
        
    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>levels</span>(self, root, levels, level):
        <span style=color:#ff79c6>if</span> root <span style=color:#ff79c6>is</span> <span style=color:#ff79c6>not</span> None:
            levels[root] <span style=color:#ff79c6>=</span> level
            self<span style=color:#ff79c6>.</span>levels(root<span style=color:#ff79c6>.</span>left, levels, level <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>)
            self<span style=color:#ff79c6>.</span>levels(root<span style=color:#ff79c6>.</span>right, levels, level <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>1</span>)
        <span style=color:#ff79c6>else</span>:
            <span style=color:#ff79c6>return</span>
</code></pre></div><p>This solution is O(n) time and got faster than 92.08%.</p></article></div><section class=article-navigation><p><a class=link href=/posts/binary-tree-right-side-view/><span class=li></span>Binary Tree Right Side View</a class="link"></p></section></section><section id=footer class="footer max-body-width"><div class=footer-wrap><p class=copyright>Anton's Algorithms</p></div><div class=footer-wrap><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener>CC BY-NC-SA 4.0</a><span> | </span><a href=/index.xml target=_blank rel=noopener>RSS</a></div><div class=footer-wrap><p class=powerby><span>Powered by </span><a href=https://gohugo.io target=_blank rel=noopener>Hugo</a><span> and the </span><a href=https://github.com/qdzhang/hugo-notepadium-mod target=_blank rel=noopener>Notepadium-mod</a></p></div><div class=footer-wrap><a onclick='window.scrollTo({top:0,behavior:"smooth"});'>^ TOP ^</a></div></section></div></body></html>