<!DOCTYPE html>
<html lang="en">
  <head>
    
      <title>
        Queue Reconstruction By Height ::
        Anton&#39;s Daily Algorithm — A simple theme for Hugo
      </title>
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta
  name="description"
  content="link to question
My original solution from itertools import permutations class Solution: def reconstructQueue(self, people: List[List[int]]) -&amp;gt; List[List[int]]: # length is only 2000 so we can viably just check that it hold and try every perm for permutation in permutations(people): if self.constructed(permutation): return permutation return [] def constructed(self, people: List[List[int]]) -&amp;gt; bool: for index, (person, smaller) in enumerate(people): count = 0 for i in range(index): if people[i][0] &amp;gt;= person: count &#43;= 1 if count !"
/>
<meta
  name="keywords"
  content=""
/>
<meta name="robots" content="noodp" />
<link rel="canonical" href="https://antdon.me/posts/queue-reconstruction-by-height/" />





<link rel="stylesheet" href="https://antdon.me/assets/style.css" />

<link rel="stylesheet" href="https://antdon.me/style.css" />


<link
  rel="apple-touch-icon-precomposed"
  sizes="144x144"
  href="https://antdon.me/img/apple-touch-icon-144-precomposed.png"
/>
<link rel="shortcut icon" href="https://antdon.me/img/favicon.png" />


<link href="https://antdon.me/assets/fonts/Inter-Italic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://antdon.me/assets/fonts/Inter-Regular.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://antdon.me/assets/fonts/Inter-Medium.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://antdon.me/assets/fonts/Inter-MediumItalic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://antdon.me/assets/fonts/Inter-Bold.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">
<link href="https://antdon.me/assets/fonts/Inter-BoldItalic.woff2" rel="preload" type="font/woff2" as="font" crossorigin="">


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Queue Reconstruction By Height"/>
<meta name="twitter:description" content="link to question
My original solution from itertools import permutations class Solution: def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]: # length is only 2000 so we can viably just check that it hold and try every perm for permutation in permutations(people): if self.constructed(permutation): return permutation return [] def constructed(self, people: List[List[int]]) -&gt; bool: for index, (person, smaller) in enumerate(people): count = 0 for i in range(index): if people[i][0] &gt;= person: count &#43;= 1 if count !"/>



<meta property="og:title" content="Queue Reconstruction By Height" />
<meta property="og:description" content="link to question
My original solution from itertools import permutations class Solution: def reconstructQueue(self, people: List[List[int]]) -&gt; List[List[int]]: # length is only 2000 so we can viably just check that it hold and try every perm for permutation in permutations(people): if self.constructed(permutation): return permutation return [] def constructed(self, people: List[List[int]]) -&gt; bool: for index, (person, smaller) in enumerate(people): count = 0 for i in range(index): if people[i][0] &gt;= person: count &#43;= 1 if count !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://antdon.me/posts/queue-reconstruction-by-height/" />
<meta property="article:published_time" content="2022-06-29T20:29:10+10:00" />
<meta property="article:modified_time" content="2022-06-29T20:29:10+10:00" /><meta property="og:site_name" content="Anton&#39;s Daily Algorithm" />






  </head>
  <body class="light-theme">
    <div class="container">
      <header class="header">
  <span class="header__inner">
    <a
  href="https://antdon.me"
  class="logo"
  style="text-decoration: none;"
>
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367" />
</svg>
</span>
    <span class="logo__text"
      >Anton&#39;s Algorithims</span
    >
    <span class="logo__cursor"></span>
  
</a>

    <span class="header__right">
      
      <span class="theme-toggle">
        <svg
  class="theme-toggler"
  width="24"
  height="24"
  viewBox="0 0 48 48"
  fill="none"
  xmlns="http://www.w3.org/2000/svg"
>
  <path
    d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"
  />
</svg>

      </span>
    </span>
  </span>
</header>


      <div class="content">
        
  
  

  <div class="post">
    <h1 class="post-title">Queue Reconstruction By Height</h1>
    <div class="post-meta">
      
        <span class="post-date">
          2022-06-29
        </span>

        
          
        
      

      


      
    </div>

    

    

    <div class="post-content">
      
      <p><a href="https://leetcode.com/problems/queue-reconstruction-by-height/">link to question</a></p>
<h2 id="my-original-solution">My original solution</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> itertools <span style="color:#f92672">import</span> permutations
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">reconstructQueue</span>(self, people: List[List[int]]) <span style="color:#f92672">-&gt;</span> List[List[int]]:
        <span style="color:#75715e"># length is only 2000 so we can viably just check that it hold and try every perm</span>
        <span style="color:#66d9ef">for</span> permutation <span style="color:#f92672">in</span> permutations(people):
            <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>constructed(permutation):
                <span style="color:#66d9ef">return</span> permutation
        <span style="color:#66d9ef">return</span> []
    
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">constructed</span>(self, people: List[List[int]]) <span style="color:#f92672">-&gt;</span> bool:
        <span style="color:#66d9ef">for</span> index, (person, smaller) <span style="color:#f92672">in</span> enumerate(people):
            count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
            <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(index):
                <span style="color:#66d9ef">if</span> people[i][<span style="color:#ae81ff">0</span>] <span style="color:#f92672">&gt;=</span> person:
                    count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
                    
            <span style="color:#66d9ef">if</span> count <span style="color:#f92672">!=</span> smaller:
                <span style="color:#66d9ef">return</span> False
        <span style="color:#66d9ef">return</span> True

</code></pre></div><p>Essentially this solution works by creating a check to see if the list is constructed and then checking every permutation. I thought I could do this because len(people) is only 2000 but in reality this was far too slow.</p>
<h2 id="ys-solution">Y&rsquo;s solution</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>: 
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">reconstructQueue</span>(self, people: List[List[int]]) <span style="color:#f92672">-&gt;</span> List[List[int]]: 
people<span style="color:#f92672">.</span>sort(key<span style="color:#f92672">=</span><span style="color:#66d9ef">lambda</span> p: (<span style="color:#f92672">-</span>p[<span style="color:#ae81ff">0</span>], p[<span style="color:#ae81ff">1</span>])) 
res <span style="color:#f92672">=</span> [] 
<span style="color:#66d9ef">for</span> [height, order] <span style="color:#f92672">in</span> people:
res <span style="color:#f92672">=</span> res[:order] <span style="color:#f92672">+</span> [[height, order]] <span style="color:#f92672">+</span> res[order:] 
<span style="color:#66d9ef">return</span> res
</code></pre></div><p>So here y&rsquo;s sort is interesting in my opinion. How she explained it was that the sort function applies a map to the list with the key univariat function as the maps function. It then sorts it and unmaps it. This is super powerful. So she is making reverse sorting by the first index and then regular sorting by the second index. This works because tuples are sorted by the first element first.</p>
<h2 id="beautiful-solution-from-discussion">Beautiful solution from discussion</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span>:
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">reconstructQueue</span>(self,A):
        A<span style="color:#f92672">.</span>sort( key <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> x: ( <span style="color:#f92672">-</span>x[<span style="color:#ae81ff">0</span>] , x[<span style="color:#ae81ff">1</span>] ) ) 
        B <span style="color:#f92672">=</span> []
        <span style="color:#66d9ef">for</span> (h,k) <span style="color:#f92672">in</span> A:
            B<span style="color:#f92672">.</span>insert( k , (h,k) )
        <span style="color:#66d9ef">return</span> B

</code></pre></div><p>This solution uses Y&rsquo;s sort thing. Then it inserts based on the second argument which is supposed to be the number of values smaller than it.  Python pushes the value at the index you are inserting in to the right. Your allowed to do this because when you are inserting an element into the list all the elements currently in the list have a larger h value. Thus, when they look left they will see the same number of elements that have greater h&rsquo;s than them. This took me awhile to wrap my head around. If you don&rsquo;t understand after reading the above code snippit a few times I suggest you draw out an example to prove to yourself that this works.</p>

    </div>
    
      
        <div class="pagination">
          <div class="pagination__title">
            <span class="pagination__title-h"
              >Read other posts</span
            >
            <hr />
          </div>
          <div class="pagination__buttons">
            
              <span class="button previous">
                <a href="https://antdon.me/posts/maximum-units-on-a-truck/">
                  <span class="button__icon">←</span>
                  <span class="button__text">Maximum Units on a Truck</span>
                </a>
              </span>
            
            
              <span class="button next">
                <a href="https://antdon.me/posts/minimum-moves-to-equal-array-elements-ii/">
                  <span class="button__text">Minimum Moves to Equal Array Elements II</span>
                  <span class="button__icon">→</span>
                </a>
              </span>
            
          </div>
        </div>
      
    

    
      
        

      
    
  </div>

      </div>

      
        <footer class="footer">
  <div class="footer__inner">
    
      <a
  href="https://antdon.me"
  class="logo"
  style="text-decoration: none;"
>
  
    <span class="logo__mark"><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44">
  <path fill="none" d="M15 8l14.729 14.382L15 35.367" />
</svg>
</span>
    <span class="logo__text"
      >Anton&#39;s Algorithims</span
    >
    <span class="logo__cursor"></span>
  
</a>

      <div class="copyright">
        <span
          >© 2022 Powered by
          <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a></span
        >
        <span
          >Theme created by
          <a href="https://twitter.com/panr" target="_blank" rel="noopener">panr</a></span
        >
      </div>
    
  </div>
</footer>

<script src="https://antdon.me/assets/main.js"></script>
<script src="https://antdon.me/assets/prism.js"></script>


      
    </div>

    
  </body>
</html>
