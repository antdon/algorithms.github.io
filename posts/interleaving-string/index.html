<!doctype html><html><head><meta charset=utf-8><meta name=generator content="Hugo 0.68.3"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><meta name=keywords content><meta name=description content><meta name=author content="Anton Donohue"><meta name=copyright content="Anton Donohue"><meta http-equiv=content-language content="zh,en"><link rel=canonical href=https://antdon.me/posts/interleaving-string/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>Interleaving String&nbsp;&ndash;&nbsp;Anton's Algorithms</title><link rel=preconnect href=https://cdn.jsdelivr.net/ crossorigin><link rel=dns-prefetch href=https://cdn.jsdelivr.net/><link rel=dns-prefetch href=https://fonts.gstatic.com/><link rel=preload href=/css/core.min.4f47bbabbe1a95ba05bcbf7bff887938361467f1f25096a6a09541fcdfaf6f9eb55c16db012e40db452cfb1b4c0fc26a.css as=style onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel=stylesheet href=/css/core.min.4f47bbabbe1a95ba05bcbf7bff887938361467f1f25096a6a09541fcdfaf6f9eb55c16db012e40db452cfb1b4c0fc26a.css integrity=sha384-T0e7q74alboFvL97/4h5ODYUZ/HyUJamoJVB/N+vb561XBbbAS5A20Us+xtMD8Jq></noscript><style type=text/css>*,::before,::after{margin:0;padding:0;box-sizing:border-box}html{font-family:-system-ui,-apple-system,BlinkMacSystemFont,helvetica neue,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol;font-size:17px;font-weight:400;line-height:1.7;scroll-behavior:smooth;transition:color .3s,background-color .3s;word-wrap:break-word;-webkit-text-size-adjust:100%}html[data-theme=dark] img{opacity:.65;transition:opacity .5s ease-in-out}html{background:#fff;--site-name-color: #3f4b67;--color-primary: #005ab4;--link-underline: #90cff9;--blockquote-border-left: 6px solid #0051a2;--block-background-color: #f7faff;--pag-background-color: rgba(0, 122, 255, .5);--box-shadow: 1px 1px 2px rgba(0,0,0,.125);--title-color: #303033;--body-color: #444}html[data-theme=dark]{background:#22272e;--site-name-color: #539bf5;--color-primary: #99bde1;--link-underline: #0051a2;--blockquote-border-left: 6px solid #5176bf;--block-background-color: #002c58;--box-shadow: none;--title-color: #dadada;--body-color: #e9e9e9}h1,h2,h3,h4,h5,h6{font-weight:600;line-height:1.3;margin-block-start:0;margin-block-end:0}h1{font-size:26px}h2{font-size:24px}h3{font-size:22px}section>h1{color:var(--title-color)}a{color:var(--color-primary);text-decoration-thickness:.15rem;text-decoration-color:var(--link-underline)}a:hover{text-decoration-color:var(--color-primary)}.wrapper{display:grid;grid-template-columns:1fr min(65ch,calc(100% - 64px)) 1fr;grid-column-gap:32px}.wrapper>section{grid-column:2}.header{margin:20px 0;display:-webkit-flex;display:flex;flex-wrap:wrap;text-align:initial;padding:15px 0;border-bottom:1px solid #f0f0f0;justify-content:space-between;align-items:baseline}.site-name{display:inline-block;font-weight:600;font-size:21px;color:var(--site-name-color)}.site-logo{height:38px;border-radius:3px;vertical-align:middle;margin-right:8px}.nav-item{display:inline-block;font-size:18px;padding:4px 6px;margin:2px 3px 2px 0;line-height:1.5;white-space:nowrap}.data-theme-btn{border:none;vertical-align:middle;transition:.3s;background-color:Transparent;background-repeat:no-repeat;cursor:pointer;overflow:hidden;outline:none;padding-right:0;padding-left:0}html[data-theme=light] .light-hidden{display:none}html[data-theme=dark] .dark-hidden{display:none}.note-list{margin:0;padding:0;list-style:none}.note-list .item{position:relative;width:100%;margin-top:25px}.note-list .item:last-child{border:0!important}.note-title{font-size:19px;font-weight:700}.note-date,.note-content{font-size:15px;text-decoration:none;color:var(--body-color)}.note-content,.note-imgs,.note-labels{margin-top:4px;text-align:justify;text-justify:inter-word}.article-tag,.article-category{display:inline-block;font-size:15px;line-height:1;padding:4px 6px;margin:2px 3px 2px 0;white-space:nowrap;border-radius:3px}.article-category{color:#3a8c42}.article-category .hashtag,.article-tag .hashtag{font-weight:700;opacity:.5}.footer{font-size:13px;margin:40px 0 20px}.footer-wrap{text-align:center;color:var(--body-color)}.tag-cloud{margin:2em 0 3em;text-align:center}.tag-cloud-tags{display:inline-block;position:relative;margin:5px;word-wrap:break-word;overflow-wrap:break-word}.archive-year{font-size:20px;font-weight:800;color:var(--title-color);margin-top:20px;margin-bottom:10px}.archive-list{list-style:none}.archive-date{flex:0 0 100px;color:var(--title-color)}.archive-text{color:var(--body-color)}ul.archive-list li{display:flex}.article-containter{margin-bottom:20px}.article-header{margin:20px 0}.article-date{font-size:14px;margin-top:20px;color:#838387}.lastmod-date{font-size:14px;color:#838387}.markdown-body{color:var(--body-color)}.markdown-body p{margin-top:0;margin-bottom:20px}.pagination{display:block;text-align:center;margin:20px 0 40px}.pagination ul{display:inline-block;list-style:none;font-weight:600;padding:0;margin:0}.pagination ul li{display:inline}.pagination ul li a{color:var(--color-primary);float:left;padding:8px 16px;text-decoration:none}.pagination ul li a:hover:not(.active){background-color:var(--pag-background-color)}.pagination ul li a.active{background-color:var(--color-primary);color:var(--block-background-color)}</style></head><body><div class=wrapper><section id=header class=header><div class=header-left><a href=/><p class=site-name>Anton's Algorithms</p></a></div><div class=header-right></div></section><section id=content><div class=article-containter><section class=article-header><h1>Interleaving String</h1><p class=article-date>2022-07-07</p></section><section class=article-labels><a class="article-tag li" href=/tags/code/><span class=hashtag>#</span>code</a><a class="article-tag li" href=/tags/algorithms/><span class=hashtag>#</span>algorithms</a></section><article class=markdown-body><h1 id=problem-explanation>Problem Explanation</h1><p>The question is asking us whether s3 is a combination of s1 and s2. The image below explains how s1 and s2 need to be combined better than I could do wit words.</p><p><a target=_blank rel="noopener noreferrer" href=/interleave.jpg><img loading=lazy src=/interleave.jpg width=100% height=auto alt=interleave.jpg></a></p><p>To check if s3 is a combination of s1 and s2 of this form at first glance it might seem like we can iterate through s3 checking if element is equal to s1[0] or s2[0] and remove the element it&rsquo;s equal to. However, if you look at the above example the order that you pop the element out matters. If you. On the 4th iteration (index 3), we would need to choose to draw from s2 inorder to find true. If we drew from s1 we would find that when we hit the last two elements of s3 we would have s1 empty and s2 with the correct two elements but in the wrong order.</p><h1 id=solution>Solution</h1><p>Whenever you have a problem and you realise you need to make a decision at every element that you wont know the correctness of until you finish the iteration you should take that as a sign to consider using <a href=https://www.geeksforgeeks.org/dynamic-programming/ target=_blank rel=noopener>dynamic programming</a>. Another give away is if the size of the iterable is small as this is necessary since DP is so inefficient.
So in this case for each element in s3 we could either draw it from s1 or s2. We want to return True if by the end of s3 we have drawn all the elements from s1 and s2. If the end of these things doesn&rsquo;t occur at the same time then we should return False. Furthermore, if at anypoint the element we are looking for in s3 can&rsquo;t be found in the next element of s1 or s2 then we should also return False.
Let&rsquo;s get coding and start with the base case.
The first thing that should disqualify a case is if the lengths of s1 and s2 don&rsquo;t combine to the length of s3. Regardless of the elements if this fact isn&rsquo;t true then we can&rsquo;t combine s1 and s2 to make s3 with no remainders.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>len</span>(s1) <span style=color:#ff79c6>+</span> <span style=color:#8be9fd;font-style:italic>len</span>(s2) <span style=color:#ff79c6>!=</span> <span style=color:#8be9fd;font-style:italic>len</span>(s3):
	<span style=color:#ff79c6>return</span> False
</code></pre></div><p>We also need our True stop condition. Since we will be reducing the size of s1 or s2 as we draw from it and reducing s3 each time we find an element that matches it&rsquo;s first element, we can see that the success case is having all three strings as empty.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#ff79c6>if</span> <span style=color:#ff79c6>not</span> s1 <span style=color:#ff79c6>and</span> <span style=color:#ff79c6>not</span> s2 <span style=color:#ff79c6>and</span> <span style=color:#ff79c6>not</span> s3:
	<span style=color:#ff79c6>return</span> True
</code></pre></div><p>Now our recursive case. The first thing to check is where we can draw our element from. We can either draw it from s1 or s2 or both. We should check both first as having both is a harder to fulfill condition.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#ff79c6>if</span> s1[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> s3[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>and</span> s2[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> s3[<span style=color:#bd93f9>0</span>]:
<span style=color:#ff79c6>...</span>
<span style=color:#ff79c6>elif</span> s1[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> s3[<span style=color:#bd93f9>0</span>]:
<span style=color:#ff79c6>...</span>
<span style=color:#ff79c6>elif</span> s2[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> s3[<span style=color:#bd93f9>0</span>]:
<span style=color:#ff79c6>...</span>
<span style=color:#ff79c6>else</span>:
<span style=color:#ff79c6>...</span>
</code></pre></div><p>It&rsquo;s important to note that at some point we may get an empty list and checking the 0 index of an empty list will cause an index error. We can avoid this by noticing that if the list is empty we wont be drawing from it and that the empty s3 case is already taken care of by our base cases.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#ff79c6>if</span> s1 <span style=color:#ff79c6>and</span> s1[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> s3[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>and</span> s2 <span style=color:#ff79c6>and</span> s2[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> s3[<span style=color:#bd93f9>0</span>]:
<span style=color:#ff79c6>...</span>
<span style=color:#ff79c6>elif</span> s1 <span style=color:#ff79c6>and</span> s1[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> s3[<span style=color:#bd93f9>0</span>]:
<span style=color:#ff79c6>...</span>
<span style=color:#ff79c6>elif</span> s2 <span style=color:#ff79c6>and</span> s2[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> s3[<span style=color:#bd93f9>0</span>]:
<span style=color:#ff79c6>...</span>
<span style=color:#ff79c6>else</span>:
<span style=color:#ff79c6>...</span>
</code></pre></div><p>Further note that this is possible because if conditions are <a href=https://stackoverflow.com/questions/13960657/does-python-evaluate-ifs-conditions-lazily target=_blank rel=noopener>lazily evaluated</a> and python considers the empty list <a href=https://www.freecodecamp.org/news/truthy-and-falsy-values-in-python/ target=_blank rel=noopener>falsey</a>.</p><p>The first choice is the complex one. We want True to propograte out of our recursive calls. So if we make a recursive call for each option we and one is True we want to return True. This will propogate up the chain of choices to tell us if it was possible by the end. We can do this using a logical or because False or True comes out as True. Further if we get to the end and at no point did we reach our end state, then we have only Falses sothe function returns False.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#ff79c6>return</span> self<span style=color:#ff79c6>.</span>isInterleave(s1[<span style=color:#bd93f9>1</span>:],s2,s3[<span style=color:#bd93f9>1</span>:]) <span style=color:#ff79c6>or</span> self<span style=color:#ff79c6>.</span>isInterleave(s1, s2[<span style=color:#bd93f9>1</span>:], s3[<span style=color:#bd93f9>1</span>:])
</code></pre></div><p>Note that we are reducing the size of the list we are drawing from and the size of s3 so that we can always just look at the first element and not need to keep track of an index.</p><p>The other two recursive cases follow on from this one. Either drawing from s1 or s2 depending on which as the value to be drawn from.
If we can&rsquo;t find the value at either s1 or s2 then we naturally have to return False.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Solution</span>:
    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>isInterleave</span>(self, s1: <span style=color:#8be9fd;font-style:italic>str</span>, s2: <span style=color:#8be9fd;font-style:italic>str</span>, s3: <span style=color:#8be9fd;font-style:italic>str</span>) <span style=color:#ff79c6>-&gt;</span> <span style=color:#8be9fd;font-style:italic>bool</span>:
        <span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>len</span>(s1) <span style=color:#ff79c6>+</span> <span style=color:#8be9fd;font-style:italic>len</span>(s2) <span style=color:#ff79c6>!=</span> <span style=color:#8be9fd;font-style:italic>len</span>(s3):
            <span style=color:#ff79c6>return</span> False
        <span style=color:#ff79c6>elif</span> <span style=color:#ff79c6>not</span> s1 <span style=color:#ff79c6>and</span> <span style=color:#ff79c6>not</span> s2 <span style=color:#ff79c6>and</span> <span style=color:#ff79c6>not</span> s3 <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>:
            <span style=color:#ff79c6>return</span> True
        
        <span style=color:#ff79c6>if</span> s1 <span style=color:#ff79c6>and</span> s1[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> s3[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>and</span> s2 <span style=color:#ff79c6>and</span> s2[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> s3[<span style=color:#bd93f9>0</span>]:
            <span style=color:#ff79c6>return</span> self<span style=color:#ff79c6>.</span>isInterleave(s1[<span style=color:#bd93f9>1</span>:],s2,s3[<span style=color:#bd93f9>1</span>:]) <span style=color:#ff79c6>or</span> self<span style=color:#ff79c6>.</span>isInterleave(s1, s2[<span style=color:#bd93f9>1</span>:], s3[<span style=color:#bd93f9>1</span>:])
        <span style=color:#ff79c6>elif</span> s1 <span style=color:#ff79c6>and</span> s1[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> s3[<span style=color:#bd93f9>0</span>]:
            <span style=color:#ff79c6>return</span> self<span style=color:#ff79c6>.</span>isInterleave(s1[<span style=color:#bd93f9>1</span>:], s2, s3[<span style=color:#bd93f9>1</span>:])
        <span style=color:#ff79c6>elif</span> s2 <span style=color:#ff79c6>and</span> s2[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> s3[<span style=color:#bd93f9>0</span>]:
            <span style=color:#ff79c6>return</span> self<span style=color:#ff79c6>.</span>isInterleave(s1, s2[<span style=color:#bd93f9>1</span>:], s3[<span style=color:#bd93f9>1</span>:])
        <span style=color:#ff79c6>else</span>:
            <span style=color:#ff79c6>return</span> False
</code></pre></div><h1 id=optimisation>optimisation</h1><p>The solution above is too slow by leetcodes standards. Generally with dynamic programming this is because you are calculating something more than once. For instance if we think about the example strings <code>s1 = "aaaaa", s2 = "aaaaa", s3 = "aaaaaaaaaa"</code>, we will be making the forking recursive call every time. If we choose to draw from s1 and then s2 we will be in the same state as if we drew from s2 and then s1. Finding times when we have the same state in two paths and subsequently are calculating it twice is a sign of inefficiency. We can fix this by storing the value of the function given the inputs and returning it when it&rsquo;s needed instead of calling of recalculating it. I showed an example of this in yesterday&rsquo;s problem [[Fibbonacci Number]]. For this question I just used python&rsquo;s built in functools @cache decorator that does that for you.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#ff79c6>import</span> functools
<span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Solution</span>:
    @cache
    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>isInterleave</span>(self, s1: <span style=color:#8be9fd;font-style:italic>str</span>, s2: <span style=color:#8be9fd;font-style:italic>str</span>, s3: <span style=color:#8be9fd;font-style:italic>str</span>) <span style=color:#ff79c6>-&gt;</span> <span style=color:#8be9fd;font-style:italic>bool</span>:
        <span style=color:#ff79c6>if</span> <span style=color:#8be9fd;font-style:italic>len</span>(s1) <span style=color:#ff79c6>+</span> <span style=color:#8be9fd;font-style:italic>len</span>(s2) <span style=color:#ff79c6>!=</span> <span style=color:#8be9fd;font-style:italic>len</span>(s3):
            <span style=color:#ff79c6>return</span> False
        <span style=color:#ff79c6>elif</span> <span style=color:#ff79c6>not</span> s1 <span style=color:#ff79c6>and</span> <span style=color:#ff79c6>not</span> s2 <span style=color:#ff79c6>and</span> <span style=color:#ff79c6>not</span> s3 <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>:
            <span style=color:#ff79c6>return</span> True
        
        <span style=color:#ff79c6>if</span> s1 <span style=color:#ff79c6>and</span> s1[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> s3[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>and</span> s2 <span style=color:#ff79c6>and</span> s2[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> s3[<span style=color:#bd93f9>0</span>]:
            <span style=color:#ff79c6>return</span> self<span style=color:#ff79c6>.</span>isInterleave(s1[<span style=color:#bd93f9>1</span>:],s2,s3[<span style=color:#bd93f9>1</span>:]) <span style=color:#ff79c6>or</span> self<span style=color:#ff79c6>.</span>isInterleave(s1, s2[<span style=color:#bd93f9>1</span>:], s3[<span style=color:#bd93f9>1</span>:])
        <span style=color:#ff79c6>elif</span> s1 <span style=color:#ff79c6>and</span> s1[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> s3[<span style=color:#bd93f9>0</span>]:
            <span style=color:#ff79c6>return</span> self<span style=color:#ff79c6>.</span>isInterleave(s1[<span style=color:#bd93f9>1</span>:], s2, s3[<span style=color:#bd93f9>1</span>:])
        <span style=color:#ff79c6>elif</span> s2 <span style=color:#ff79c6>and</span> s2[<span style=color:#bd93f9>0</span>] <span style=color:#ff79c6>==</span> s3[<span style=color:#bd93f9>0</span>]:
            <span style=color:#ff79c6>return</span> self<span style=color:#ff79c6>.</span>isInterleave(s1, s2[<span style=color:#bd93f9>1</span>:], s3[<span style=color:#bd93f9>1</span>:])
        <span style=color:#ff79c6>else</span>:
            <span style=color:#ff79c6>return</span> False
</code></pre></div><p>Here is an example that I found of doing the caching by hand.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Solution</span>:
    <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>isInterleave</span>(self, s1: <span style=color:#8be9fd;font-style:italic>str</span>, s2: <span style=color:#8be9fd;font-style:italic>str</span>, s3: <span style=color:#8be9fd;font-style:italic>str</span>) <span style=color:#ff79c6>-&gt;</span> <span style=color:#8be9fd;font-style:italic>bool</span>:
        cache <span style=color:#ff79c6>=</span> {}
        s1_arr <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>list</span>(s1)
        s2_arr <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>list</span>(s2)
        s3_arr <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>list</span>(s3)
        
        <span style=color:#ff79c6>if</span> s1 <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#34;&#34;</span>:
            <span style=color:#ff79c6>return</span> s3 <span style=color:#ff79c6>==</span> s2
        <span style=color:#ff79c6>elif</span> s2 <span style=color:#ff79c6>==</span> <span style=color:#f1fa8c>&#34;&#34;</span>:
            <span style=color:#ff79c6>return</span> s1 <span style=color:#ff79c6>==</span> s3
        <span style=color:#ff79c6>elif</span> <span style=color:#8be9fd;font-style:italic>len</span>(s1) <span style=color:#ff79c6>+</span> <span style=color:#8be9fd;font-style:italic>len</span>(s2) <span style=color:#ff79c6>!=</span> <span style=color:#8be9fd;font-style:italic>len</span>(s3):
            <span style=color:#ff79c6>return</span> False

        <span style=color:#ff79c6>def</span> <span style=color:#50fa7b>dp</span>(i, k):
            <span style=color:#ff79c6>if</span> k <span style=color:#ff79c6>-</span> i <span style=color:#ff79c6>&lt;</span> <span style=color:#bd93f9>0</span> <span style=color:#ff79c6>or</span> i <span style=color:#ff79c6>&lt;</span> <span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>:
                <span style=color:#ff79c6>return</span> False
            <span style=color:#ff79c6>if</span> k <span style=color:#ff79c6>&lt;</span> <span style=color:#bd93f9>0</span>:
                <span style=color:#ff79c6>return</span> True
    
            <span style=color:#ff79c6>else</span>:
                <span style=color:#ff79c6>if</span> (i, k) <span style=color:#ff79c6>in</span> cache:
                    <span style=color:#ff79c6>return</span> cache[(i, k)]
                    
                <span style=color:#ff79c6>else</span>:
                    j <span style=color:#ff79c6>=</span> k <span style=color:#ff79c6>-</span> i <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>
                    
                    can_do <span style=color:#ff79c6>=</span> False
                    <span style=color:#ff79c6>if</span> s1_arr[i] <span style=color:#ff79c6>==</span> s3_arr[k]:
                        can_do <span style=color:#ff79c6>=</span> can_do <span style=color:#ff79c6>or</span> dp(i <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>, k <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>)
                    <span style=color:#ff79c6>if</span> s2_arr[j] <span style=color:#ff79c6>==</span> s3_arr[k]:
                        can_do <span style=color:#ff79c6>=</span> can_do <span style=color:#ff79c6>or</span> dp(i, k <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>)
                    
                    cache[(i, k)] <span style=color:#ff79c6>=</span> can_do
                    
                    <span style=color:#ff79c6>return</span> can_do
                
        <span style=color:#ff79c6>return</span> dp(<span style=color:#8be9fd;font-style:italic>len</span>(s1) <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>, <span style=color:#8be9fd;font-style:italic>len</span>(s3) <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>)
</code></pre></div></article></div><section class=article-navigation><p><a class=link href=/posts/binary-tree-right-side-view/><span class=li></span>Binary Tree Right Side View</a></p><p><a class=link href=/posts/fibbonacci-number/><span class=li></span>Fibbonacci Numbers</a class="link"></p></section></section><section id=footer class="footer max-body-width"><div class=footer-wrap><p class=copyright>Anton's Algorithms</p></div><div class=footer-wrap><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener>CC BY-NC-SA 4.0</a><span> | </span><a href=/index.xml target=_blank rel=noopener>RSS</a></div><div class=footer-wrap><p class=powerby><span>Powered by </span><a href=https://gohugo.io target=_blank rel=noopener>Hugo</a><span> and the </span><a href=https://github.com/qdzhang/hugo-notepadium-mod target=_blank rel=noopener>Notepadium-mod</a></p></div><div class=footer-wrap><a onclick='window.scrollTo({top:0,behavior:"smooth"});'>^ TOP ^</a></div></section></div></body></html>